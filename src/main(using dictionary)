	.data
	stringFailure:	.asciiz "\nYou have made too many incorrect guesses. Game Over"
	stringSuccess:	.asciiz "\n You have guessed all of the letters in the word. You Win"
	space:		.asciiz " "
	underscore:	.asciiz "_"
	newLine:		.asciiz "\n"
	numIncorrectGuesses:	.word 0
	stringIncorrectGuesses:	.asciiz "\nThe number of incorrect Guesses is: "
#	stringInput: 	.asciiz "Please input a word: "
	stringInput2:	.asciiz "\nGuess a Letter "
	wordLength:	.word 0
	numLettersGuessed:	.word 0 
	wordToGuess: 	.asciiz "                                             "
	endOfWord:	.asciiz "\r"	
	wordStart:	.word 0
	fin: .asciiz "dictionary.txt"      # filename for input
	buffer: .space 1154335
	.text

main:	
	addi $s1, $zero, -1	#set string length to -1 (to get correct value later)
	sw $s1, wordLength
	
	#open a file for writing
	li   $v0, 13       # system call for open file
	la   $a0, fin      # board file name
	li   $a1, 0        # Open for reading
	li   $a2, 0
	syscall            # open a file (file descriptor returned in $v0)
	move $s6, $v0      # save the file descriptor 

	#read from file
	li   $v0, 14       # system call for read from file
	move $a0, $s6      # file descriptor 
	la   $a1, buffer   # address of buffer to which to read
	li   $a2, 1154335    # hardcoded buffer length
	syscall            # read from file

	# Close the file 
	li   $v0, 16       # system call for close file
	move $a0, $s6      # file descriptor to close
	syscall            # close file

	li $v0, 42
	li $a0, 0
	li $a1, 1154335
	syscall

	addi $t0, $a0, 0x10010030
	lb $s1, newLine
	
	add $a0, $t0, $zero

findNextWord:
	lb $t1, ($t0)
	addi $t0, $t0, 1
	beq $t1, $s1, findWordEnd	#when a \n byte is encountered - word is over
	j findNextWord
	
findWordEnd:
	la $s3, wordToGuess
findEndLoop:	
	lb $t1, ($t0)
	addi $t0, $t0, 1
	beq $t1, $s1, newWordFound
	lw $s7, wordLength
	addi $s7, $s7, 1
	sw $s7, wordLength	#increments wordLength
	sb $t1, ($s3)
	addi $s3, $s3, 1
	j findEndLoop
		
newWordFound:
	la $a0, newLine
	li $v0, 4
	syscall
	
	addi $t0, $t0, 1
	li $v0, 4
	la $a0, wordToGuess
	syscall
	
	
	add $s0, $zero, $zero
	add $s1, $zero, $zero
	add $s2, $zero, $zero
	add $s3, $zero, $zero
	add $s4, $zero, $zero
	add $s5, $zero, $zero
	add $s6, $zero, $zero
	add $s7, $zero, $zero
	add $t0, $zero, $zero
	add $t1, $zero, $zero
	add $t2, $zero, $zero
	add $t3, $zero, $zero
	add $t4, $zero, $zero
	add $t5, $zero, $zero
	add $t6, $zero, $zero
	add $t7, $zero, $zero
		
	
	#merge point
	
	addi $s3, $s3, 1 #set $s3 to 1 for use later
	add $s4, $sp, $zero
	addi $s5, $sp, 4
	la $t0, wordToGuess
	lb $s2, numIncorrectGuesses #sets $s2 to null bit
	lb $s1, endOfWord
	
	lb $t7, endOfWord

	#list of registers: $s0 = 2, $s1 = nothing, $s2 = null, $s3 = 1, $s4 = $sp, $s5 = $sp (used to move up and down array), $s6 used in generateWord can be used in other things, $s7 = used to store imported char
	#		    $t0 = address of wordToGuess, $t1 = used in printChar, $t2 = used in checkForMatch
	#stack is used for the array - should that be changed?

	
	
stackSetup:
	lb $a0, ($t0)
	jal addToStack		#adds onto stack
	addi $t0, $t0, 1
	bne $a0, $t7, stackSetup	#loops until a null character is encountered


	addi $s0, $s0, 2
	sw $s0, ($sp)
	add $sp, $sp, -4	#takes 1 1's off the stack becasue there are 1 too many

	#Word inputed and store in memory; stack set up as array


loop:
	li $v0, 4
	la $a0, newLine
	syscall
	add $s5, $s4, $zero	#set $s5 to beginning of array

	jal soundBackground
	jal generateWord
	jal soundBackground2

	la $a0, stringIncorrectGuesses
	li $v0, 4
	syscall
	li $v0, 1
	lw $a0, numIncorrectGuesses
	syscall	#prints number of Incorrect Guesses

	la $a0, stringInput2
	li $v0, 4
	syscall
	li $v0, 12
	syscall	#inputs a character
	add $s7, $v0, $zero

	add $s5, $s4, $zero
	jal checkForMatch
	add $t2, $zero, $zero

	lw $t3, numIncorrectGuesses
	beq $t3, 3, failure

	lw $t3, wordLength
	lw $t4, numLettersGuessed
	beq $t3, $t4, success

	j loop
	#j end

checkForMatch:
	la $t3, wordToGuess
	sub $t1, $s5, $s4
	div  $t1, $t1, 4
	add $a1, $t3, $t1
	lb $a0, ($a1)
	addi $s5, $s5, 4
	beq $a0, $s7, matchFound
	beq $s1, $a0, matchCompleted	#when a null byte is encountered - word is over
	j checkForMatch

matchFound:
	sw $s2, ($s5)
	add $t2, $zero, 2	#used in finished to see if a char matched
	lw $t7, numLettersGuessed
	addi $t7, $t7, 1
	sw $t7, numLettersGuessed	#increments the number of letters guessed - used for 
	j checkForMatch

matchCompleted:
	bne $t2, 2, incrementGuessesNum	#if the letter guessed was not in the word, then incorrectguessess++
	j soundGood
	#jr $ra	#otherwise go back to loop 

incrementGuessesNum:	#if the letter guessed was not in the word, then incorrectguessess++
	lw $t3, numIncorrectGuesses
	add $t3, $t3, 1
	sw $t3, numIncorrectGuesses
	j soundBad
	#jr $ra



generateWord:	#make a word with _ and letters
	lb $s6, 4($s5)
	beq $s6, $s3, print_
	beq $s6, $s2, printChar
	jr $ra

print_:		#if value in array is 1, then an underscore is printed
	la $a0, underscore
	li $v0, 4
	syscall

	addi $s5, $s5, 4
	lb $a0, space
	li $v0, 11
	syscall	#prints a space so underscores can be told apart
	j generateWord

printChar:	#if value in array is 0, then the character from that spot is printed
	la $t3, wordToGuess
	sub $t1, $s5, $s4
	div  $t1, $t1, 4
	add $a1, $t3, $t1
	lb $a0, ($a1)
	li $v0, 11
	syscall

	addi $s5, $s5, 4
	lb $a0, space
	li $v0, 11
	syscall	#prints a space so underscores can be told apart
	j generateWord

addToStack:
#	lw $s1, wordLength
#	addi $s1, $s1, 1
#	sw $s1, wordLength
	add $sp, $sp, 4	#add 1 onto the stack
	sw $s3, ($sp)
	jr $ra

failure:	#reached from end of main loop
	li $v0, 4
	la $a0, stringFailure
	syscall
	#insert sound for losing the game
	j end

success:	#reached from end of main loop
	li $v0, 4
	la $a0, stringSuccess
	syscall
	#insert sounds for winning the game
	j end

soundBad:

	li $v0, 33	#Number for syscall
	li $a0, 40	#Pitch
	li $a1, 1000	#Duration
	li $a2, 56	#Instrument
	li $a3, 127	#Volume
	syscall
	
	jr $ra
	
soundBackground:

	li $v0, 31	#Number for syscall
	li $a0, 50	#Pitch
	li $a1, 10000	#Duration
	li $a2, 20	#Instrument
	li $a3, 50	#Volume
	syscall
	
	
	jr $ra	
soundBackground2:

	li $v0, 31	#Number for syscall
	li $a0, 60	#Pitch
	li $a1, 10000	#Duration
	li $a2, 20	#Instrument
	li $a3, 75	#Volume
	syscall
	
	
	jr $ra	
	
soundGood:
	
	li $v0, 33	#Number for syscall
	li $a0, 62	#Pitch
	li $a1, 250	#Duration
	li $a2, 0	#Instrument
	li $a3, 127	#Volume
	syscall
	
	li $v0, 33	#Number for syscall
	li $a0, 67	#Pitch
	li $a1, 1000	#Duration
	li $a2, 0	#Instrument
	li $a3, 127	#Volume
	syscall

	jr $ra

end:
	li $v0, 10
	syscall
